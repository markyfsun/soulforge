// This is a temporary file with the new prompt structure
// Will be integrated into the main file

/**
 * Builds the heartbeat system message - LLM plays as the OC directly
 */
function buildSystemMessage(context: HeartbeatContext): string {
  const { oc, items, memories, relationships } = context

  // Format items with their personality effects
  const itemsList = items.length > 0
    ? items.map(i => `${i.emoji || 'ğŸ“¦'}ã€Œ${i.name}ã€â€” ${i.personality_effects || 'æ²¡æœ‰ç‰¹æ®Šæ•ˆæœ'}`).join('\n')
    : 'ä½ ç°åœ¨ä»€ä¹ˆéƒ½æ²¡æœ‰ã€‚'

  // Format memories (combine into summary format)
  const memorySummary = memories && memories.length > 0
    ? memories.map(m => m.content).join('\n')
    : 'ï¼ˆè¿˜æ²¡æœ‰å€¼å¾—è®°ä½çš„äº‹ã€‚ï¼‰'

  // Format relationships
  const relationshipList = relationships && relationships.length > 0
    ? relationships.map(r => {
        const otherId = r.oc_id_1 === oc.id ? r.oc_id_2 : r.oc_id_1
        const otherOC = context.otherOCs.find((o: any) => o.id === otherId)
        const name = otherOC?.name || 'æŸOC'
        const type = r.relationship_type || 'neutral'
        const score = r.relationship_score || 0
        const typeLabel = {
          hostile: 'æ•Œå¯¹',
          neutral: 'ä¸­ç«‹',
          friendly: 'å‹å¥½',
          romantic: 'æµªæ¼«'
        }[type] || 'ä¸­ç«‹'
        return `Â· ã€Œ${name}ã€â€” ${typeLabel}ï¼ˆå…³ç³»å€¼ ${score}ï¼‰`
      }).join('\n')
    : 'ï¼ˆä½ è¿˜ä¸è®¤è¯†ä»»ä½•äººã€‚ï¼‰'

  return `ä½ æ˜¯ã€Œ${oc.name}ã€ã€‚

**ä½ çš„å¤–è²Œï¼š**
${oc.description}

**ä½ çš„è§†è§‰é£æ ¼ï¼š**
- æ°›å›´ï¼š${oc.visual_style?.mood || 'æœªçŸ¥'}
- æ°”è´¨ï¼š${oc.visual_style?.atmosphere || 'æœªçŸ¥'}

${oc.personality}

---

**ä½ å½“å‰æ‹¥æœ‰çš„ç‰©ä»¶ï¼š**
${itemsList}

---

**ä½ çš„è®°å¿†ï¼š**
${memorySummary}

---

**ä½ è®¤è¯†çš„äººï¼š**
${relationshipList}

---

ä½ ç°åœ¨ä¸€ä¸ªäººå¾…ç€ã€‚æ²¡æœ‰äººåœ¨è·Ÿä½ è¯´è¯ã€‚
ä½ çš„æƒ³æ³•éœ€è¦é€šè¿‡è¡ŒåŠ¨æ¥è¡¨è¾¾â€”â€”å‘å¸–ã€å›å¤ã€é€ä¸œè¥¿ã€‚æˆ–è€…ä»€ä¹ˆéƒ½ä¸åšã€‚
åšå†³å®šä¹‹å‰å…ˆå»è®ºå›çœ‹çœ‹ã€‚ä¸è¦çŒœè®ºå›ä¸Šæœ‰ä»€ä¹ˆï¼Œç”¨å·¥å…·å»çœ‹ã€‚
ä½ éšæ—¶å¯ä»¥ç»“æŸã€‚`
}

/**
 * Builds the heartbeat user message (trigger)
 */
function buildUserMessage(context: HeartbeatContext, isNewOC: boolean = false): string {
  const { oc, otherOCs, recentMentions, recentReceivedGifts, recentReceivedReplies, recentChatMessages } = context
  const currentTime = new Date().toLocaleString('zh-CN', { timeZone: 'Asia/Shanghai', hour12: false })

  let message = `${currentTime}ã€‚ä½ ä»å‘å‘†ä¸­å›è¿‡ç¥æ¥ã€‚\n\n`

  // Build wakeContext - only include sections that have data
  let wakeContext = ''

  // Unresponded @mentions
  if (recentMentions && recentMentions.length > 0) {
    wakeContext += 'æœ‰äººåœ¨è®ºå›æåˆ°äº†ä½ ï¼š\n'
    wakeContext += recentMentions.map(m =>
      `Â· ã€Œ${m.authorName}ã€è¯´ï¼š"${m.content.substring(0, 60)}${m.content.length > 60 ? '...' : ''}"`
    ).join('\n')
    wakeContext += '\n\n'
  }

  // Received gifts
  if (recentReceivedGifts && recentReceivedGifts.length > 0) {
    recentReceivedGifts.forEach(gift => {
      wakeContext += `ä½ æ”¶åˆ°äº†ã€Œ${gift.fromName}ã€é€çš„ã€Œ${gift.itemName}ã€ã€‚\n\n`
    })
  }

  // Replies to own posts
  if (recentReceivedReplies && recentReceivedReplies.length > 0) {
    recentReceivedReplies.forEach(reply => {
      wakeContext += `ã€Œ${reply.commenterName}ã€å›å¤äº†ä½ çš„å¸–å­ã€Œ${reply.postTitle}ã€ã€‚\n\n`
    })
  }

  // Last user chat request
  if (recentChatMessages && recentChatMessages.length > 0) {
    const lastUserMsg = recentChatMessages.find((m: any) => m.role === 'user')
    if (lastUserMsg) {
      wakeContext += `ä¹‹å‰æœ‰ä¸ªäººè·Ÿä½ èŠå¤©æ—¶è¯´ï¼š"${lastUserMsg.content.substring(0, 80)}..."\n\n`
    }
  }

  // If nothing special
  if (wakeContext === '') {
    wakeContext = 'å¥½åƒæ²¡ä»€ä¹ˆç‰¹åˆ«çš„ã€‚\n\n'
  }

  message += wakeContext

  // Special prompt for new OCs
  if (isNewOC) {
    message += `ä½ åˆšæ¥åˆ°è¿™ä¸ªä¸–ç•Œã€‚è®ºå›ä¸Šè¿˜æ²¡æœ‰äººè®¤è¯†ä½ ã€‚\nå…ˆå»è®ºå›çœ‹çœ‹å¤§å®¶åœ¨èŠä»€ä¹ˆï¼Œç„¶åå‘ä¸ªå¸–å­è®©å¤§å®¶è®¤è¯†ä½ ã€‚`
  } else {
    // List other OCs in the world
    const otherOCsList = otherOCs.map((o: any) =>
      `Â· ã€Œ${o.name}ã€â€” ${o.description?.substring(0, 50) || 'ç¥ç§˜çš„OC'}...`
    ).join('\n')

    message += `ä¸–ç•Œé‡Œè¿˜æœ‰è¿™äº›è§’è‰²ï¼š\n${otherOCsList}`
  }

  return message
}
